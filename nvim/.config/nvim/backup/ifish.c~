#include "header.h"
#include <unistd.h>
#include <sys/wait.h>
#define CHECK_BIT(var,pos) ((var) & (1ULL<<(pos)))


struct Node{
    int dataindex[15];
    int length;
    struct Node *next;
    struct Node *prev;
};
struct Node *tmp = NULL;
struct Node *last = NULL;
struct Node *root = NULL;
struct Node *current = NULL;


//Global veriables!
char *hist;
uint64_t *bitmap;

int prompt(int com){
    static int counter = 1;
    char* user = getenv("USER");
    if(com == 1){
        counter --;
        return 0;
    }
    return printf("%s@ifish %i>",user,counter++);
}

char* readIn(){
    char s[121];
    char *string = fgets(s, sizeof(s) ,stdin);
    if (string == NULL){
        printf("\nthe system exited \n");
        //free(string);
        exit(0);
    }
#ifdef DEBUG
    printf("string= %s" , string);
#endif
    return string;
}

int *path(char **args){

    int fork_bg = 1;
    int i;
    for(i=0;args[i] != NULL; i++);
    if(i != 0 && (strcmp(args[i-1], "&")==0)){
        fork_bg = 0;
        args[i-1] = NULL;
    }
    int pid;
    if((pid = safefork()) == 0){
        char *pa = strdup(getenv("PATH"));
        char *paths = strtok(pa, ":");
        char filename[121];
        extern char **environ;
        while(paths != NULL){
            sprintf(filename,"%s/%s", paths, args[0]);
#ifdef DEBUG
            printf("%s \n",filename);
            printf("args %s \n", *args);
#endif
            execve(filename, args, environ);
            paths = strtok(NULL, ":");
        }
        printf("ifish: %s: command not found \n" , args[0]);
        exit(-1);
    }else if(fork_bg){
        int status;
        waitpid(pid,&status,0);
    }else{
        printf("[%d] %s\n", pid, args[0]);
    }
    return 0;
}

void history_print(){

    printf("\nHistory list of the last 10 commands:");

    char cmd[121];
    memset(cmd,0,121);

    tmp = root;

    while(tmp!=NULL){
        int i=0;
        while((tmp->dataindex[i])!=0){
            strncpy(cmd+8*i, hist+tmp->dataindex[i], 8);
            i++;
        }
        printf("%s\n", cmd);
        memset(cmd,0,121);
        tmp=tmp->next;

    }
}

void history(char *hist_buf){
    char *tmpstr = strtok(hist_buf, "\n");
    printf("%s",tmpstr);
    int numblocks;
    int len_buf = strlen(tmpstr) + 1;
    int mod = strlen(tmpstr) %8;
    int i;

    if(len_buf < 8) {
        numblocks = 1;
    }else if(mod > 0 || len_buf > 8){
        numblocks = len_buf / 8;
        numblocks += 1;
    } else {
        numblocks = len_buf / 8;
    }

    tmp = malloc(sizeof(struct Node));
    memset(tmp, 0, sizeof(*tmp));
    tmp -> length = len_buf;

    for (i=0; i<numblocks; i++){
        int pos = check_bit();
        memcpy(hist+8+(pos*8), tmpstr+(i*8),8);
        tmp -> dataindex[i] = 8+(8*pos);
        //else {
        //   printf("something is wrong");
        //}
    }

    if (root == NULL){
        current = root = tmp;
    } else{
        current = current -> next = tmp;
    }

    free(tmpstr);
}

void history_rep(){
}
void history_delete(){
}
void set_hist(){
    hist = malloc(sizeof(char) * 520);
    memset(hist, 0, 520);
    bitmap = (uint64_t*) hist;
}

int check_bit(){
    int i;
    for(i=0; i <64; i++){
        if(CHECK_BIT(*bitmap, i)){
            *bitmap |= 1ULL << i;
            return i;
        }
    }
    printf("fail");
    return -1;
}

int main (int argv, char* argc[]){
#ifdef DEBUG
    printf("Ifish - debugmode \n");
#endif
    set_hist();
    while (1){
        if (prompt(0) < 0){
            printf("error in reading user");
            exit(1);
        }
        char *word = readIn();
        int i;
        int j=0;
        int teller = 0;
        int len = strlen(word);
        char tmp[len];
        for (i = 0; i < len; i++){
            tmp[i] = word[i];
        }
        char *hist = strdup(tmp);
        history(hist);

        char* param[21] = {NULL};
        int boolean = 0;

        for(i=0;i<len;i++){
            if (boolean == 0){
                j = i;
            }
            if(isspace(tmp[i]) == 0){
                boolean = 1;
            }
            if (boolean){
                if(isspace(tmp[i]) != 0){
                    tmp[i] = '\0';
                    param[teller++] = &tmp[j];
                    j = i;
                    boolean = 0;
                }
            }
        }
        if(len == 1){
            prompt(1);
        }
#ifdef DEBUG
        if(param[0] != NULL){
            for(i=0;param[i] != NULL;i++){
                printf("param[%d] = '%s' \n",i, param[i]);
            }
        }
#endif
        if(param[0] != NULL){
            if (!strcmp(param[0], "exit") || !strcmp(param[0], "quit")){
                exit(0);
            }
            else if(!strcmp(param[0], "h") || !strcmp(param[0], "history")){
                history_print();
                if (param[1] != NULL){
                    if(!strcmp(param[1], "i")){
                        history_rep();
                    }else if(!strcmp(param[i], "-d")){
                        history_delete();
                    }
                }
            }else{
                path(param);
            }
            continue;
        }

#ifdef DEBUG
        else{
            printf("param[0] = NULL\n");
        }
#endif
    }
    return 0;
}

